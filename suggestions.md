## A. 码率自适应传输 (ABR) 与 QoE 统计

这是流媒体的核心功能之一。

* **目标：** 客户端根据网络状况或播放流畅度，动态选择不同码率（质量）的视频分片进行下载和播放。
* **实现步骤：**
    1.  **服务端准备：** 确保你已经为同一个视频内容生成了多种不同码率/分辨率的分片和对应的M3U8文件（例如，`480p-1500k/`, `720p-4000k/`, `1080p-8000k/`）。服务器的元数据接口 (`METADATA`) 也应该能为不同质量提供信息。
        * （可选高级）服务器可以提供一个“主M3U8播放列表”，其中列出所有可用的码率版本的M3U8地址。客户端可以先请求这个主列表。但对于你的项目，客户端直接知道有哪些 `quality_suffix` 可用，或者通过一个自定义的“获取可用质量列表”的API也可以。
    2.  **客户端ABR决策逻辑（核心）：**
        * **状态监测：**
            * **基于缓冲区 (Buffer-based)：** 这是相对容易实现的。监测当前已下载并加入播放列表、但尚未播放的分片的总时长（或数量）。
                * `当前缓冲时长 = (已加入列表的最后一个分片的原始索引 - 当前播放分片的原始索引) * 平均分片时长` (这是一个估算)。
                * 设置高水位线（例如 `BUFFER_HIGH_SEC = 20秒`）和低水位线（例如 `BUFFER_LOW_SEC = 8秒`）。
            * **基于吞吐量 (Rate-based)：** 测量最近下载分片的速度。
                * `吞吐量 = 下载的字节数 / 下载耗时`。需要对这个值进行平滑处理（例如使用滑动平均）。
        * **码率选择算法：**
            * **Buffer-based 示例：**
                * 如果缓冲时长 < `BUFFER_LOW_SEC`，则选择一个比当前码率更低的质量等级。
                * 如果缓冲时长 > `BUFFER_HIGH_SEC`，并且网络状况（可以用吞吐量辅助判断）允许，则尝试选择一个比当前码率更高的质量等级。
                * 为了防止码率频繁波动，可以增加一些“迟滞”逻辑，例如连续几次观察到缓冲高/低才切换，或者切换后保持一段时间不再切换。
            * **Rate-based 示例：**
                * 获取可用的质量等级列表及其对应的码率值。
                * 选择一个码率最接近但不超过（或乘以一个安全因子如0.8后不超过）估算出的网络吞吐量的质量等级。
    3.  **客户端执行切换：**
        * 当ABR算法决定切换到新的 `new_quality_suffix` 时：
            * **停止当前下载线程**（如果它还在为旧质量下载）。
            * **清空VLC的 `MediaList` 中尚未播放的旧质量分片**（或者让它们播完，新质量从下一个逻辑分片开始——后者体验更好）。这是一个关键的设计选择。如果选择播完旧的，那么新的下载任务需要从旧质量列表的最后一项的下一个逻辑分片开始请求新质量。
            * **向服务器请求新质量的元数据** (`METADATA video_name/new_quality_suffix`)，因为总分片数可能略有不同。
            * **启动（或重置）下载线程**，使用新的 `new_quality_suffix` 和新的起始分片索引来下载后续分片。
            * 新的分片会被加入到（可能已部分清空的）`MediaList` 中。
    4.  **QoE (用户体验质量) 统计：**
        * **平均播放码率：** 记录每个播放过的分片的码率（可以从文件名或元数据中获得）及其精确时长（从M3U8中）。加权平均 `sum(码率_i * 时长_i) / sum(时长_i)`。
        * **卡顿次数和总时长：**
            * 当播放器状态变为缓冲 (`vlc.EventType.MediaPlayerBuffering` 事件，且缓冲值较低时），或者当 `MediaListPlayer` 尝试播放下一项但该项还未下载好导致播放暂停时，计为一次卡顿。
            * 记录每次卡顿的开始和结束时间，累加总卡顿时间。
        * **码率切换次数：** 每次ABR算法决定更改 `quality_suffix` 时，计数器加一。
        * **PSNR (峰值信噪比) / SSIM (结构相似性)：**
            * 这些是客观视频质量评估指标。在你的项目中，**实时计算非常困难**。
            * 通常的做法是**离线分析**：
                1.  让客户端在播放时，除了播放外，也将所有**实际解码并呈现给用户**的分片（按顺序）保存下来。
                2.  实验结束后，将这些保存的分片（可能是混合码率的）拼接成一个完整的视频文件。
                3.  使用FFmpeg的 `psnr` 或 `ssim` 滤镜，将这个拼接后的视频与一个高质量的原始参考视频（未压缩或极高码率版）进行比较。
                    ```bash
                    ffmpeg -i reassembled_output.mp4 -i original_reference.mp4 -lavfi "psnr=stats_file=psnr_log.txt" -f null -
                    ffmpeg -i reassembled_output.mp4 -i original_reference.mp4 -lavfi "ssim=stats_file=ssim_log.txt" -f null -
                    ```
                4.  分析生成的日志文件。
            * 对于你的项目，你可能只需要在报告中论述PSNR/SSIM作为QoE指标，并说明如何测量，而不一定需要完整实现其自动化测量。或者，专注于更容易在客户端直接统计的QoE指标。

* **模拟网络带宽骤降场景：**
    * **Linux：`tc`** （最灵活）
        ```bash
        # 初始高带宽 (例如 10Mbps)
        sudo tc qdisc add dev eth0 root tbf rate 10mbit burst 128kbit latency 50ms
        # 运行客户端，开始播放
        # ... 一段时间后，骤降到低带宽 (例如 1Mbps)
        sudo tc qdisc replace dev eth0 root tbf rate 1mbit burst 32kbit latency 50ms
        # 观察客户端日志和播放行为（是否切换到低码率，是否卡顿）
        # ... 再恢复到高带宽
        sudo tc qdisc replace dev eth0 root tbf rate 10mbit burst 128kbit latency 50ms
        # 别忘了测试结束后清除规则
        sudo tc qdisc del dev eth0 root
        ```
    * **macOS：Network Link Conditioner (GUI)**
        * 预设或自定义一个高带宽配置，开始播放。
        * 手动切换到一个低带宽配置（例如 "Very Bad Network" 或自定义的低带宽）。
        * 观察客户端反应。
    * **Windows：Clumsy (第三方工具)**
        * 启动Clumsy，设置过滤规则（例如针对到服务器的端口或IP）。
        * 开始时关闭带宽限制或设置较高值。
        * 播放开始后，在Clumsy中启用并设置一个较低的带宽限制。
    * **测试不同带宽下的卡顿率和（离线）PSNR对比分析：**
        1.  **固定带宽测试：** 使用上述工具将网络带宽固定在几个不同的水平（例如，很高、中等、刚好够某个低码率、低于所有码率）。
        2.  在每种固定带宽下，运行你的客户端从头到尾播放一个固定的测试视频。
        3.  **记录QoE：**
            * 客户端自动记录卡顿次数、总卡顿时间、平均播放码率、码率切换次数（如果有ABR的话，对于固定带宽测试，ABR可能不会切换或只在开始时选择一个）。
            * （如果做PSNR）保存该次播放的所有分片，拼接后与原始视频计算PSNR。
        4.  **对比分析：** 制作表格或图表，对比在不同固定带宽下，这些QoE指标的表现。例如，带宽越低，卡顿率是否越高，平均播放码率是否越低，PSNR是否越差。
        5.  **ABR效果展示：** 使用动态带宽变化（高->低->高）来演示你的ABR算法是否能成功切换码率，并记录这个过程中的QoE指标。与不使用ABR（例如固定播放最高码率）在该网络波动下的表现进行对比。

## B. 滑动窗口流式处理

这个扩展任务与我们为解决“卡顿”问题所做的后台下载和预缓冲逻辑密切相关，目标是实现更精细的缓冲管理和无缝播放。

* **核心概念：** 维护一个固定大小（或动态调整大小）的“窗口”或缓冲区，其中包含即将播放的若干个视频分片。当播放器消耗掉窗口头部的分片时，窗口“滑动”，新的分片从网络获取并加入到窗口尾部。
* **在你当前 `python-vlc` 客户端中的实现：**
    1.  **下载线程 (`_download_and_manage_segments_task`) 作为生产者：** 它负责根据“滑动窗口”的需要（即窗口尾部有空位）来下载新的分片。
    2.  **VLC的 `MediaList` 作为缓冲和播放队列（消费者的一部分）：** 下载好的分片被加入到这个列表中。
    3.  **`Workspace_AHEAD_TARGET` 定义了窗口中领先于当前播放点的部分大小。**
    4.  **“滑动”的体现：**
        * **内容进入：** 下载线程添加新分片到 `MediaList`。
        * **内容消耗：** `MediaListPlayer` 播放 `MediaList` 中的分片。
        * **内容移出（清理）：** `on_media_changed_callback` 中实现的旧分片文件删除逻辑，可以看作是将已播放完毕并“滑出”可视/近期缓冲窗口的分片从磁盘移除。
* **如何进一步“支持长视频流无缝播放”和“重组机制”：**
    * **健壮的缓冲逻辑是关键：**
        * 下载线程需要非常精确地知道播放器当前消耗到哪个分片了 (`currently_playing_original_idx`)。
        * 它需要判断“逻辑缓冲池”中还有多少未播放的分片（`已下载并加入列表的总数 - (当前播放索引 + 1)`）。
        * 当这个逻辑缓冲池的大小低于某个阈值（例如 `Workspace_AHEAD_TARGET / 2`）时，下载线程应该被唤醒并积极下载，直到缓冲池再次填满到 `Workspace_AHEAD_TARGET`。
        * 可以使用 `threading.Condition` 来更有效地在下载线程和播放器事件（表明分片已消耗）之间进行同步，而不是简单地 `time.sleep()`。下载线程可以等待一个条件变量，当缓冲水位低时被主线程（通过VLC事件回调）通知。
    * **“重组机制”：** 对于TS分片，主要的“重组”是由播放器（VLC `MediaListPlayer`）处理的，它会按顺序播放列表中的分片。你的代码主要负责按正确的顺序下载并将它们提供给播放列表。如果涉及到更复杂的例如乱序到达的TS包的重组，那通常是在更底层的网络传输或媒体解析层面，对于你的应用层TCP传输，分片是按序到达的，文件本身是完整的。所以这里的“重组”更多是指按逻辑顺序管理和播放这些独立的分片文件。
    * **处理播放列表动态变化：** 当ABR切换码率时，你可能需要清空 `MediaList` 中旧码率的未播放分片，然后加入新码率的分片。`MediaListPlayer` 需要能平滑处理这种列表内容的动态变化。

## C. 端到端加密传输 (AES)

* **目标：** 保护视频内容在传输过程中的机密性。
* **实现步骤：**
    1.  **密钥管理：**
        * 最简单的方式：**预共享密钥 (Pre-Shared Key, PSK)**。客户端和服务器硬编码或通过配置文件加载相同的AES密钥。
        * （可选高级）更安全的方式：动态密钥交换（如 Diffie-Hellman），但这会显著增加复杂性。对于课程项目，PSK通常足够。
    2.  **加密标准：** AES-128 或 AES-256。
    3.  **加密模式：**
        * **CBC (Cipher Block Chaining) 模式：** 常用，需要一个唯一的初始化向量 (Initialization Vector, IV) 用于每个加密操作（即每个分片）。IV不需要保密，可以与密文一起传输（例如，放在加密数据的前面）。
        * **CTR (Counter) 模式：** 也很好，同样需要唯一的IV（通常称为nonce）。
        * **GCM (Galois/Counter Mode)：** 提供加密和认证，更好但可能稍复杂。
    4.  **Python库：** `cryptography` 库 (`from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes`)。
    5.  **服务端修改 (`handle_client` 中发送分片的部分)：**
        * 当客户端请求一个TS分片时：
            a.  从磁盘读取原始（明文）TS分片数据。
            b.  **生成一个随机的、唯一的IV** (对于AES，通常是16字节)。
            c.  使用预共享密钥和这个IV，通过AES（例如CBC模式）加密TS分片数据。注意可能需要对数据进行填充 (padding) 以满足块密码的块大小要求，或者使用能处理任意长度数据的流式加密模式如CTR。
            d.  构造要发送的数据包：例如 `IV + 加密后的TS数据`。
            e.  在发送 `OK <file_size>\n` 头部时，这里的 `file_size` 应该是 **IV长度 + 加密后TS数据长度**。
            f.  发送这个组合数据。
    6.  **客户端修改 (`_download_and_manage_segments_task` 中接收和保存分片的部分)：**
        * 在接收到 `OK <size>` 和后续的数据后：
            a.  从接收到的数据开头提取IV（例如，前16字节）。
            b.  剩余的数据是加密的TS数据。
            c.  使用与服务器相同的预共享密钥和提取到的IV，解密加密的TS数据。如果加密时有填充，解密后需要去除填充。
            d.  将**解密后的明文TS数据**写入本地临时文件。
            e.  然后将这个解密后的本地文件路径加入VLC播放列表。
    7.  **日志：** 服务器可以记录它正在发送加密数据，客户端可以记录它正在解密。

这个修改对现有的文件传输协议影响较大（因为文件大小和内容都变了），但加密/解密逻辑本身是相对独立的模块。
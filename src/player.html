<!DOCTYPE html>
<html>
<head>
    <title>Stream Smart ABR - SJTU CS3611</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        :root {
            --primary-text-color: #2c3e50;   /* Deep grayish blue - for main text */
            --secondary-text-color: #34495e; /* Lighter grayish blue - for subtitles and labels */
            --accent-color: #3498db;       /* Bright blue - for highlights and links */
            --background-color: #ecf0f1;   /* Very light gray - page background */
            --container-background: #ffffff; /* White - panel background */
            --panel-border-color: #bdc3c7;    /* Light gray - panel borders */
            --shadow-color: rgba(0, 0, 0, 0.08); /* Softer shadow */
            --success-color: #2ecc71;      /* Green - for success states */
            --error-color: #e74c3c;        /* Red - for error states */
            --font-family: 'Roboto', sans-serif; /* Using Roboto font */
            --base-font-size: 16px;
            --border-radius: 8px;          /* Larger rounded corners */
        }

        body {
            font-family: var(--font-family);
            font-size: var(--base-font-size);
            margin: 0;
            background-color: var(--background-color);
            color: var(--primary-text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 25px; /* Increased page padding */
            min-height: 100vh;
            box-sizing: border-box;
            line-height: 1.6; /* Improved readability */
        }

        .header-section {
            text-align: center;
            margin-bottom: 10px; /* Spacing between title and content below */
            padding: 10px;
        }

        .main-title {
            color: var(--primary-text-color);
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
        }

        .course-project-subtitle {
            color: var(--secondary-text-color);
            font-size: 1.2em;
            font-weight: 300;
            margin-top: 0;
            margin-bottom: 25px;
        }

        .main-container {
            width: 100%;
            max-width: 950px; /* Slightly wider main content area */
            display: flex;
            flex-direction: column;
            gap: 25px; /* Gap between video container and info panels */
        }

        #videoContainer {
            background-color: #000;
            box-shadow: 0 5px 20px var(--shadow-color);
            border-radius: var(--border-radius);
            overflow: hidden;
            width: 100%;
            border: 1px solid var(--panel-border-color); /* Added border to video container */
        }

        video {
            width: 100%;
            display: block;
            border-radius: var(--border-radius);
        }

        .info-panels-container {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            width: 100%;
        }

        .panel {
            background-color: var(--container-background);
            padding: 25px; /* Increased panel padding */
            border-radius: var(--border-radius);
            box-shadow: 0 3px 10px var(--shadow-color);
            flex: 1 1 300px; /* Panels grow, base width 300px, allow wrapping */
            box-sizing: border-box;
            border: 1px solid var(--panel-border-color); /* Added border to panels */
        }

        .panel h2 {
            margin-top: 0;
            font-size: 1.5em; /* Adjusted panel title size */
            font-weight: 500;
            color: var(--primary-text-color);
            border-bottom: 1px solid #e7e7e7; /* Thinner separator line */
            padding-bottom: 12px;
            margin-bottom: 18px;
        }

        .panel p {
            margin: 10px 0; /* Adjusted paragraph spacing */
            font-size: 1.2em;
        }

        .panel .label {
            font-weight: 500;
            color: var(--secondary-text-color);
            margin-right: 8px; /* Space between label and value */
        }

        .panel .value {
            color: var(--accent-color);
            font-weight: 400;
            word-break: break-all;
        }

        /* Status-specific colors */
        .status-good { color: var(--success-color); }
        .status-bad { color: var(--error-color); }
        .status-neutral { color: var(--secondary-text-color); }

        /* Responsive stacking for smaller screens */
        @media (max-width: 768px) {
            .info-panels-container {
                flex-direction: column;
            }
            .panel {
                min-width: 100%; /* Full width on small screens */
            }
        }

        .footer-credits {
            margin-top: 25px; /* Increased spacing above footer */
            padding: 25px;
            text-align: center;
            font-size: 1.3em;
            color: #7f8c8d; /* Footer text color */
            width: 100%;
            max-width: 900px;
            border-top: 1px solid #dadce0; /* Modern separator line color */
            background-color: var(--container-background); /* Footer can have a background */
            box-shadow: 0 -2px 5px var(--shadow-color); /* Slight shadow above footer */
            border-radius: var(--border-radius) var(--border-radius) 0 0; /* Rounded top corners for footer */
        }

        .footer-credits p {
            margin: 6px 0;
        }
        .footer-credits .team-lead { /* Example: style for team lead */
            font-weight: 500;
        }

    </style>
</head>
<body>
    <div class="header-section">
        <h1 class="main-title">Stream Smart ABR</h1>
        <p class="course-project-subtitle">SJTU-CS3611 Course Project</p>
    </div>

    <div class="main-container">
        <div id="videoContainer">
            <video id="videoPlayer" controls playsinline poster="placeholder-poster.png"></video>
        </div>

        <div class="info-panels-container">
            <div class="panel" id="playbackInfoPanel">
                <h2>Current Stream Info</h2>
                <p><span class="label">Video Name:</span> <span id="videoNameSpan" class="value">Loading...</span></p>
                <p><span class="label">Current Segment:</span> <span id="currentSegmentSpan" class="value">-</span></p>
                <p><span class="label">Displayed Quality:</span> <span id="displayedQualitySpan" class="value">-</span></p>
                <p><span class="label">Loading Quality:</span> <span id="loadedQualitySpan" class="value">-</span></p>
            </div>

            <div class="panel" id="networkQoePanel">
                <h2>Performance Metrics</h2>
                <p><span class="label">Buffer Level:</span> <span id="bufferLevelSpan" class="value">- s</span></p>
                <p><span class="label">Network Simulator:</span> <span id="networkSimStatusSpan" class="value">N/A</span></p>
                <p><span class="label">Estimated Bandwidth:</span> <span id="estimatedAbrBwSpan" class="value">N/A</span></p>
                <p><span class="label">Total Rebuffering:</span> <span id="rebufferingCountSpan" class="value">0 events</span>, <span id="rebufferingDurationSpan" class="value">0 ms</span></p>
            </div>
        </div>
    </div>

    <div class="footer-credits">
        <p><strong>Team Members:</strong></p>
        <p>NY Chen, RK Lin, ZF Chen, XZ Yu, QS Yao</p>
    </div>

    <script>
        /**
         * Initializes the HLS.js player, sets up WebSocket communication for ABR control and QoE reporting,
         * and attaches event listeners to track and display playback metrics.
         */
        document.addEventListener('DOMContentLoaded', function () {
            // DOM element references
            const video = document.getElementById('videoPlayer');
            
            // Placeholders to be dynamically replaced by the Python backend when serving this HTML file.
            // These define the URLs for fetching video manifests and establishing WebSocket connections.
            const videoToStreamName = "{VIDEO_TO_STREAM_NAME}";
            const localProxyHost = "{LOCAL_PROXY_HOST}";
            const localProxyPort = "{LOCAL_PROXY_PORT}";
            const websocketPort = "{WEBSOCKET_PORT}";

            // Construct the URL for the master M3U8 playlist.
            const masterM3u8Url = `http://${localProxyHost}:${localProxyPort}/${videoToStreamName}/master.m3u8`;

            // References to HTML span elements used for displaying dynamic information on the page.
            const videoNameSpan = document.getElementById('videoNameSpan');
            const currentSegmentSpan = document.getElementById('currentSegmentSpan');
            const loadedQualitySpan = document.getElementById('loadedQualitySpan');
            const displayedQualitySpan = document.getElementById('displayedQualitySpan');
            const bufferLevelSpan = document.getElementById('bufferLevelSpan');
            const networkSimStatusSpan = document.getElementById('networkSimStatusSpan');
            const estimatedAbrBwSpan = document.getElementById('estimatedAbrBwSpan');
            const rebufferingCountSpan = document.getElementById('rebufferingCountSpan');
            const rebufferingDurationSpan = document.getElementById('rebufferingDurationSpan');

            let hlsInstance = null; // Will hold the HLS.js player instance.
            const ws = new WebSocket(`ws://${localProxyHost}:${websocketPort}`); // Establishes WebSocket connection.

            // Display the video name on the page once the DOM is ready.
            if (videoNameSpan) {
                videoNameSpan.textContent = videoToStreamName;
            }

            // Variables for accumulating QoE metrics.
            let totalRebufferingEvents = 0;
            let totalRebufferingDurationMs = 0;

            /**
             * Sends QoE (Quality of Experience) event data to the Python backend via WebSocket.
             * Ensures a timestamp is added to the event data if not already present.
             * @param {object} eventData - The QoE event data object.
             * @param {string} eventData.event - The name of the QoE event (e.g., "STARTUP_LATENCY").
             * @param {*} [eventData.value] - Optional value associated with the event.
             * @param {number} [eventData.timestamp] - Optional timestamp; defaults to Date.now().
             */
            function sendQoeEvent(eventData) {
                if (ws.readyState === WebSocket.OPEN) {
                    if (!eventData.timestamp) {
                        eventData.timestamp = Date.now();
                    }
                    ws.send(JSON.stringify({ type: "QOE_EVENT", data: eventData }));
                } else {
                    // Log a warning if WebSocket is not open when trying to send an event.
                    console.warn("WebSocket not open, QoE event not sent:", eventData);
                }
            }

            // WebSocket event handlers
            ws.onopen = function() {
                console.log("WebSocket connection established.");
                // Any UI updates for WebSocket connection status could go here if needed.
            };
            ws.onclose = function() {
                console.log("WebSocket connection closed.");
            };
            ws.onerror = function(error) {
                console.error("WebSocket error:", error);
            };

            /**
             * Handles messages received from the WebSocket server.
             * This includes ABR commands (SET_LEVEL) and status updates (NETWORK_SIM_UPDATE, ABR_BW_ESTIMATE_UPDATE).
             * @param {MessageEvent} event - The WebSocket message event.
             */
            ws.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);
                    // Handles SET_LEVEL command from Python ABR to instruct HLS.js to switch quality levels.
                    if (message.type === "SET_LEVEL" && hlsInstance) {
                        const newLevelIndex = parseInt(message.levelIndex);
                        // Validate the received level index.
                        if (hlsInstance.levels && newLevelIndex >= 0 && newLevelIndex < hlsInstance.levels.length) {
                            // Set HLS.js's nextLevel property to trigger a quality switch.
                            // Only set if it's different from the current target to avoid redundant operations.
                            if (hlsInstance.nextLevel !== newLevelIndex) {
                                console.log(`Python ABR COMMAND: Set hlsInstance.nextLevel to: ${newLevelIndex}`);
                                hlsInstance.nextLevel = newLevelIndex;
                                // Update UI to show the quality level Python ABR is targeting.
                                if (loadedQualitySpan && hlsInstance.levels[newLevelIndex]) { 
                                    loadedQualitySpan.textContent = `${hlsInstance.levels[newLevelIndex].height}p @ ${(hlsInstance.levels[newLevelIndex].bitrate / 1000).toFixed(0)} kbps`;
                                }
                            }
                        } else {
                            console.warn(`Python ABR COMMAND: Invalid levelIndex ${newLevelIndex} or hlsInstance.levels not ready.`);
                        }
                    // Handles network simulator status updates from Python.
                    } else if (message.type === "NETWORK_SIM_UPDATE") { 
                        if (networkSimStatusSpan) { 
                            if (message.data && typeof message.data.bandwidth_Mbps === 'number') {
                                networkSimStatusSpan.textContent = `${message.data.bandwidth_Mbps.toFixed(2)} Mbps`;
                            } else if (message.data && message.data.status === 'Full Speed') {
                                networkSimStatusSpan.textContent = "Full Speed";
                            } else {
                                networkSimStatusSpan.textContent = "N/A";
                            }
                        }
                    // Handles Python ABR's estimated bandwidth updates.
                    } else if (message.type === "ABR_BW_ESTIMATE_UPDATE") { 
                        if (estimatedAbrBwSpan && message.data && typeof message.data.estimated_Mbps === 'number') { 
                            estimatedAbrBwSpan.textContent = `${message.data.estimated_Mbps.toFixed(2)} Mbps`;
                        } else if (estimatedAbrBwSpan) {
                            estimatedAbrBwSpan.textContent = "N/A";
                        }
                    }
                } catch (e) { console.error("Error processing message from WebSocket:", e); }
            };

            // --- QoE Event Tracking Variables & Logic ---
            let playInitiatedTimestamp = 0;   // Timestamp for when video playout is first initiated.
            let isFirstPlaySignal = true;     // Flag to ensure startup latency is measured only once.
            let isRebuffering = false;        // State flag indicating if rebuffering is currently occurring.
            let rebufferingStartTime = 0;     // Timestamp for when the current rebuffering event started.
            let jsPreviousLevel = -1;         // Stores the last known HLS.js quality level index for QoE reporting.

            // Intercept the video.play() method to accurately capture the play initiation time,
            // especially for cases like autoplay or manual play before HLS.js is fully ready.
            const originalVideoPlay = video.play;
            video.play = function(...args) {
                if (isFirstPlaySignal && playInitiatedTimestamp === 0) { 
                    playInitiatedTimestamp = Date.now();
                    console.log("QoE JS: Play initiation (manual video.play or autoplay detected) timestamped at", playInitiatedTimestamp);
                }
                return originalVideoPlay.apply(this, args);
            };

            // Video Element Event Listener: 'playing'
            // Fired when playback starts for the first time, or resumes after pausing or rebuffering.
            video.addEventListener('playing', function() {
                const currentEventTime = Date.now();
                // Calculate and report startup latency on the very first 'playing' event.
                if (isFirstPlaySignal && playInitiatedTimestamp > 0) {
                    const startupLatency = currentEventTime - playInitiatedTimestamp;
                    console.log(`QoE JS: Startup Latency = ${startupLatency} ms`);
                    sendQoeEvent({ event: "STARTUP_LATENCY", value: startupLatency, timestamp: currentEventTime });
                    // startupLatencySpan was removed from UI, so no update here.
                    isFirstPlaySignal = false; // Ensure startup latency is reported only once.
                }
                // If playback resumes after a rebuffering event, log and report the rebuffering duration.
                if (isRebuffering) {
                    isRebuffering = false; // Reset rebuffering state
                    const rebufferingDuration = currentEventTime - rebufferingStartTime;
                    totalRebufferingDurationMs += rebufferingDuration; // Accumulate total duration
                    console.log(`QoE JS: Rebuffering ended. Duration = ${rebufferingDuration} ms`);
                    sendQoeEvent({ event: "REBUFFERING_END", duration: rebufferingDuration, timestamp: currentEventTime });
                    if(rebufferingDurationSpan) rebufferingDurationSpan.textContent = `${totalRebufferingDurationMs} ms`;
                }
            });

            // Video Element Event Listener: 'waiting'
            // Fired when playback stops due to lack of data (rebuffering).
            video.addEventListener('waiting', function() {
                const currentEventTime = Date.now();
                // Check conditions to ensure it's a genuine rebuffering event
                // (not at the very start, not paused by user, not at the end of video).
                if (!isFirstPlaySignal && video.currentTime > 0 && !video.paused && !video.ended) {
                    if (!isRebuffering) { // Only start a new rebuffering event if not already in one
                        isRebuffering = true;
                        rebufferingStartTime = currentEventTime;
                        totalRebufferingEvents++; // Increment rebuffering count
                        console.log("QoE JS: Rebuffering started");
                        sendQoeEvent({ event: "REBUFFERING_START", timestamp: rebufferingStartTime });
                        if(rebufferingCountSpan) rebufferingCountSpan.textContent = `${totalRebufferingEvents} events`;
                    }
                }
            });
            
            // Video Element Event Listener: 'ended'
            // Fired when video playback reaches the end.
            video.addEventListener('ended', function() {
                console.log("QoE JS: Playback naturally ended.");
                sendQoeEvent({ event: "PLAYBACK_ENDED", timestamp: Date.now() });
                stopBufferMonitoring(); // Stop buffer monitoring when playback ends.
            });

            // Window Event Listener: 'beforeunload'
            // Fired when the window is about to be closed or navigated away from.
            window.addEventListener('beforeunload', function() {
                console.log("QoE JS: Window closing, sending PLAYBACK_ENDED.");
                sendQoeEvent({ event: "PLAYBACK_ENDED", timestamp: Date.now() });
                stopBufferMonitoring(); // Stop buffer monitoring on page unload.
            });


            // --- HLS.js Setup and Event Handling ---
            if (Hls.isSupported()) {
                // Initialize HLS.js.
                // The configuration here (autoLevelEnabled: false, startLevel: 0 in constructor)
                // was found to be problematic in previous iterations.
                // This version uses the "good version's" approach: initialize with defaults,
                // then force settings in MANIFEST_PARSED.
                hlsInstance = new Hls({ 
                    debug: false 
                    // autoLevelEnabled and startLevel are NOT set here to mimic the "good version" behavior
                    // that the user reported as working after issues with constructor settings.
                });

                // Timestamp for startup latency, captured just before HLS.js starts loading source.
                playInitiatedTimestamp = Date.now(); 
                console.log("QoE JS: Play initiation (HLS loadSource) timestamped at", playInitiatedTimestamp);
                
                hlsInstance.loadSource(masterM3u8Url); // Load the master M3U8 playlist.
                hlsInstance.attachMedia(video);         // Attach HLS.js to the HTML video element.

                // HLS.js Event: MANIFEST_PARSED
                // Fired when the HLS manifest (playlist) has been successfully loaded and parsed.
                hlsInstance.on(Hls.Events.MANIFEST_PARSED, function (event, data) { 
                    console.log("HLS.js: Manifest parsed. Levels:", data.levels.map(l => ({bitrate: l.bitrate, resolution: `${l.width}x${l.height}`})));
                    startBufferMonitoring(); // Begin periodic buffer level checks.

                    // This block replicates the logic from the user's "good version" of player.html
                    // to forcefully set the initial level and disable HLS.js's internal ABR
                    // immediately after the manifest is parsed.
                    if (hlsInstance.levels && hlsInstance.levels.length > 0) { 
                        jsPreviousLevel = 0; // Assume starting at level 0 for QoE tracking.
                        
                        // Force HLS.js to start at level 0 and disable its ABR capabilities.
                        hlsInstance.currentLevel = 0;       // Set the current playback level to index 0.
                        hlsInstance.autoLevelCapping = -1;  // Disable automatic level capping.
                        hlsInstance.autoLevelEnabled = false; // Crucially disable HLS.js's own ABR.
                        
                        console.log("HLS.js: MANIFEST_PARSED - Forcing level 0 and disabling HLS.js ABR. Initial jsPreviousLevel:", jsPreviousLevel);
                        
                        // Update UI elements to reflect the initial quality.
                        if (hlsInstance.levels[jsPreviousLevel]) { 
                            const initialQualityText = `${hlsInstance.levels[jsPreviousLevel].height}p @ ${(hlsInstance.levels[jsPreviousLevel].bitrate / 1000).toFixed(0)} kbps`;
                            if (currentQualitySpan) currentQualitySpan.textContent = initialQualityText; // Changed from displayedQualitySpan to currentQualitySpan from "good" version
                        }
                        
                        // Send an initial QUALITY_SWITCH event for QoE tracking.
                        sendQoeEvent({ 
                            event: "QUALITY_SWITCH",
                            fromLevel: -1, // Indicates no prior level.
                            toLevel: jsPreviousLevel,
                            toBitrate: hlsInstance.levels[jsPreviousLevel].bitrate,
                            timestamp: Date.now()
                        });
                    }
                });

                // HLS.js Event: LEVEL_SWITCHED
                // Fired when HLS.js has actually switched to a new quality level.
                hlsInstance.on(Hls.Events.LEVEL_SWITCHED, function(event, data) { 
                    const newLevel = data.level; // Index of the new quality level.
                    // Ensure levels array and the newLevel index are valid before accessing.
                    if (hlsInstance.levels && hlsInstance.levels[newLevel]) {
                        const newBitrate = hlsInstance.levels[newLevel].bitrate;
                        const newHeight = hlsInstance.levels[newLevel].height;
                        console.log(`HLS.js EVENT: LEVEL_SWITCHED to level index: ${newLevel}, bitrate: ${newBitrate}`);
                        // Update UI to show the quality level actually being displayed.
                        if (displayedQualitySpan) displayedQualitySpan.textContent = `${newHeight}p @ ${(hlsInstance.levels[newLevel].bitrate / 1000).toFixed(0)} kbps`; // Kept displayedQualitySpan

                        // If it's an actual change from the previously tracked level, send a QoE event.
                        if (jsPreviousLevel !== newLevel) { 
                             sendQoeEvent({ 
                                event: "QUALITY_SWITCH",
                                fromLevel: jsPreviousLevel, 
                                toLevel: newLevel,
                                toBitrate: newBitrate,
                                timestamp: Date.now()
                            });
                            jsPreviousLevel = newLevel; // Update the tracked previous level.
                        }
                    } else {
                        console.warn("LEVEL_SWITCHED event fired, but newLevel index is out of bounds or hlsInstance.levels not ready.");
                    }
                });
                
                // HLS.js Event: FRAG_CHANGED
                // Fired when HLS.js switches to playing a new fragment (segment).
                hlsInstance.on(Hls.Events.FRAG_CHANGED, function(event, data) { 
                    if (data && data.frag && currentSegmentSpan) { 
                        const frag = data.frag;
                        // Display the sequence number of the current segment.
                        currentSegmentSpan.textContent = `Segment ${frag.sn}`; 
                        console.log(`HLS.js EVENT: FRAG_CHANGED - SN: ${frag.sn}, Level: ${frag.level}, URL: ${frag.url.substring(frag.url.lastIndexOf('/') + 1)}`);
                    }
                });
                
                // HLS.js Event: ERROR
                // Fired when an error occurs within HLS.js.
                hlsInstance.on(Hls.Events.ERROR, function (event, data) { 
                    console.error('HLS.js Error:', data);
                    // Example error handling for fatal errors.
                    if (data.fatal) {
                        switch (data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.error('HLS.js: Fatal network error encountered.');
                                // hlsInstance.startLoad(); // Example recovery attempt
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.error('HLS.js: Fatal media error encountered.');
                                // hlsInstance.recoverMediaError(); // Example recovery attempt
                                break;
                            default:
                                console.error('HLS.js: Unrecoverable fatal error.');
                                // hlsInstance.destroy(); // Clean up HLS.js instance
                                break;
                        }
                    }
                });

            // Fallback for browsers that support native HLS but not HLS.js via Media Source Extensions.
            } else if (video.canPlayType('application/vnd.apple.mpegurl')) { 
                console.log("HLS.js not supported, using native HLS playback.");
                video.src = masterM3u8Url;
                // Note: Native HLS will not use the Python ABR logic or provide detailed HLS.js events.
            } else { 
                // Fallback if HLS is not supported at all.
                alert("HLS is not supported in your browser.");
            }

            // --- Buffer Monitoring Logic ---
            let bufferMonitoringInterval = null; // Interval timer for buffer monitoring.
            /**
             * Starts periodic monitoring of the video buffer level.
             * Retrieves buffer length and sends "BUFFER_UPDATE" events via WebSocket.
             */
            function startBufferMonitoring() { 
                if (bufferMonitoringInterval) { // Clear any existing interval to prevent duplicates.
                    clearInterval(bufferMonitoringInterval);
                }
                console.log("HLS.js: Starting buffer monitoring.");
                bufferMonitoringInterval = setInterval(function() {
                    // Ensure HLS instance exists and video metadata is loaded.
                    if (hlsInstance && video.readyState > 0) { 
                        let currentBufferLength = 0;
                        // Prefer hls.mainForwardBufferInfo for more accurate forward buffer length in modern HLS.js.
                        if (hlsInstance.mainForwardBufferInfo && typeof hlsInstance.mainForwardBufferInfo.len === 'number') { 
                            currentBufferLength = hlsInstance.mainForwardBufferInfo.len;
                        } else if (video.buffered && video.buffered.length > 0 && video.currentTime !== undefined) {
                            // Fallback to HTML5 video.buffered TimeRanges to calculate forward buffer.
                            for (let i = 0; i < video.buffered.length; i++) {
                                if (video.buffered.start(i) <= video.currentTime && video.currentTime < video.buffered.end(i)) {
                                    currentBufferLength = video.buffered.end(i) - video.currentTime;
                                    break;
                                }
                            }
                            // If currentTime is not within any current buffered range but buffer exists ahead
                            // (e.g., after a seek or at the very start before playback catches up).
                            if (currentBufferLength === 0 && video.buffered.length > 0 && video.buffered.end(video.buffered.length -1) > video.currentTime) { 
                                let maxEnd = video.currentTime;
                                for(let i=0; i < video.buffered.length; i++) {
                                    if (video.buffered.end(i) > maxEnd) maxEnd = video.buffered.end(i);
                                }
                                currentBufferLength = Math.max(0, maxEnd - video.currentTime);
                            }
                        }
                        if (bufferLevelSpan) bufferLevelSpan.textContent = `${currentBufferLength.toFixed(2)} s`;
                        sendQoeEvent({ event: "BUFFER_UPDATE", value: currentBufferLength });
                    }
                }, 1000); // Send buffer update every 1 second.
            }

            /**
             * Stops the periodic buffer monitoring.
             */
            function stopBufferMonitoring() { 
                if (bufferMonitoringInterval) {
                    clearInterval(bufferMonitoringInterval);
                    bufferMonitoringInterval = null;
                    console.log("HLS.js: Stopped buffer monitoring.");
                }
            }
        });
    </script>
</body>
</html>